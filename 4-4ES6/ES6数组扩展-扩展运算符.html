<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>es6数组扩展</title>
	</head>
	<body>
		
		<input type="button" id="btn" value="按钮">
		
	<script>
	// 函数调用：
	// myFunction(...iterableObj);		
	// 数组字面量或字符串：
	// [...iterableObj, '4', 'five', 6];
	// 对象字面量（ECMAScript 2018中的新增内容）：
	// let objClone = { ...obj };

	// 1.取代apply
	// function myFunction(x, y, z) { 
	// 	console.log(x,y,z)
	// }
	// var args = [0, 1, 2];
	// myFunction(...args);
	//参数列表中的任何参数都可以使用扩展语法，并且可以多次使用。
	// function myFunction(v, w, x, y, z) { 
	// 	console.log(v,w,x,y,z)
	// }
	// var args = [0, 1];
	// myFunction(-1, ...args, 2, ...[3]);
	// 2.在 new 中应用
	//当用new调用构造函数，它不可能直接使用数组和  apply （apply做了[[Call]]，而不是一个[[Construct]]）。然而，借助新的扩展语法可以轻松使用：
	var dateFields = [2018,3,11,17,12,12]; // 2018年4月11日17时12分12秒 
	var d = new Date(... dateFields);   //新建了一个以dateFields为日期的事件对象
	console.log(d)
	//3.展开数组字面量
	// 无扩散的语法，使用现有阵列作为它的一个部分创建一个新的数组，数组文本语法不再足够和命令性代码必须使用的组合来代替push，splice，concat等。随着扩展语法此变得更加简洁：
	var parts = ['shoulders','knees']; 
	var lyrics = ['head',... parts,'and','toes']; //无concat拼接数组	
	console.log(lyrics) //["head", "shoulders", "knees", "and", "toes"]
	// 浅拷贝一个数组
	var a = [[1], [2], [3]];
	var b = [...a]; 
	var [...c] = a;   //这是利用解构和rest语法，注意和上面的语法区别
	b[0].push(5)
	console.log(b,a,c)  //[[1,5],[2],[3]]
	//连接数组
	var arr1 = [0, 1, 2];
	var arr2 = [3, 4, 5];
	arr1 = [...arr1, ...arr2];
	//4.展开对象字面量
	var obj1 = { foo: 'bar', x: 42 };
	var obj2 = { foo: 'baz', y: 13 };
	var clonedObj = { ...obj1 };
	var mergedObj = { ...obj1, ...obj2 };
	//5.注意：扩展语法（除扩展属性外）只能应用于可迭代对象（可迭代对象指有Iterator接口的对象）
	var obj = {'key1': 'value1'};
	var array = [...obj];    //报错，obj不是可以迭代的对象。注意此处是[]！改成{}扩展属性可运行
	



	




	</script>
	</body>
</html>
