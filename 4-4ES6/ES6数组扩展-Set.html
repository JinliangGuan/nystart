<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>es6数组扩展</title>
	</head>
	<body>
		
		<input type="button" id="btn" value="按钮">
		<ul>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
		</ul>
	<script>
	
	var numbers = [15.5, 2.3, 1.1, 4.7]; 
	function getSum(total, num) { return total + Math.round(num); }
	console.log(numbers.reduce(getSum,0));
	
	var numbers = [65, 44, 12, 4]; 
	function getSum(total, num) { return total + num; } 
	console.log(numbers.reduce(getSum))

	//1.新建一个Set并用add添加数据
	const s = new Set();
	[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));   //.add的方法可以
	for (let i of s) {
		console.log(i); //=>2 3 5 4 并不会重复
	}
	//2.new Set()可以接收一个数组,.size可以查看Set成员数量
	const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
	console.log(items.size) // 5  
	//3.new Set()可以接收一个类数组
	const set3 = new Set(document.querySelectorAll('li'));
	console.log(set3)
	//4.Set去重。原理：Set中不允许有重复项
	var arr = [1,2,3,2,1];
	arr2 = [... new Set(arr)]
	console.log(arr2)  //=>[1,2,3]
	
	//set的属性和方法
	var s5 = new Set();
	s5.add(1).add(2).add(3).add(2);  //2被加入了两次
	console.log(s5.size)  //=>3
	console.log(s5.has(1))  //=>true
	s5.delete(1)            
	console.log(s5.has(1))  //=>false

	//set遍历
	//（1）keys()，values()，entries()
	//keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。
	let set = new Set(['red', 'green', 'blue']);
	for (let item of set.keys()) {   //等同于(let item of set.values())
		console.log(item);   //=> 'red' // 'green'// 'blue'
	}	
	for (let item of set) {   //可以省略values方法，直接用for...of循环遍历 Set。等同于set.values();
		console.log(item);   //=> 'red' // 'green'// 'blue'
	}
	for (let item of set.entries()) {   //等同于(let item of set.values())
		console.log(item);   
		//=> ["red", "red"]  // ["green", "green"]  //["blue", "blue"]  
		//entries方法返回的遍历器，同时包括键名和键值。而遍历Set中他们是相等的。
	}
	//（2）forEach()
	//Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。
	set = new Set([1, 4, 9]);
	set.forEach((value, key) => console.log(key + ' : ' + value))   //=>//1 : 1//4 : 4//9 : 9//set的key==value
	//另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象


	//去重的另一种方法
	function dedupe(array) {
		return Array.from(new Set(array));
	}
	//console.log(dedupe([1, 1, 2, 3])) // [1, 2, 3]

	//Array(7)和Array.of(7)
	// console.log(Array.of(7));
	// console.log(Array(7));
	
	console.log(set.has(0))



	</script>
	</body>
</html>
